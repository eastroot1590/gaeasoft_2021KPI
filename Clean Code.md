# Clean Code

## 0. 서론

이 문서는 *Robert. C. Martin*의 책 **Clean Code**를 읽고 정리하는 문서로 책에서 제시하는 좋은 코드를 작성하기 위해 책에서 제시하는 아이디어를 요약합니다. 요약을 위해서 짧은 문장과 **규칙**이라는 목록으로 아이디어를 나열하듯 작성했지만 책에서도 서술하듯이, 이 아이디어들이 반드시 지켜야 하는 법칙은 아니기 때문에 코드를 작성하면서 참고하면 좋을 것 같습니다.

## 1. 깨끗한 코드

깨끗한 코드는 잘 쓴 하나의 문장처럼 읽어지는 코드를 말한다. 즉, 코드를 읽으면서 짐작했던 기능을 그대로 수행한다면 깨끗한 코드라고 할 수 있다.

### 1.1. 규칙

- 중복을 피한다.
- 하나의 코드묶음은 하나의 기능만 수행한다.
- 제대로 표현한다.
- 작게 추상화한다.

위 아이디어를 지키면서 **주의 깊게** 코드를 작성하도록 한다.

불가피하게 모듈에 기능을 추가하거나 수정을 해야 한다면 수정하기 전보다 더 깨끗하게 만들어 놓고 빠져나오겠다는 마음가짐을 가지고 있어야 한다.

## 2. 의미있는 이름

의도가 분명하게 이름을 짓는 것은 **정말** 중요하다. 존재 이유, 수행 기능, 사용 방법을 모두 이름을 통해 짐작할 수 있어야 한다. 이름이 다르다면 의미도 달라져야 하며 비슷한 이름은 지양해야 한다. 

### 2.1. 규칙

- 실제 단어를 사용한다. 임의로 만들어낸 새로운 단어나 `i`같은 알파벳 이름은 지양한다.
- 클래스 이름으로는 명사를 사용한다.
- 메서드 이름으로는 동사를 사용한다.

맥락이 있는 이름을 사용해서 더 빠르게 의미를 짐작할 수 있도록 한다. `state` 보다는 `addrState`가, 더 나아가서 `addressState`가 더 좋은 이름이다.

## 3. 함수

함수를 작게 만들수록 상위 함수의 흐름을 이해하기 쉬워진다. 함수를 작게 만들 수록 코드를 더욱 문장처럼 작성할 수 있다. 극단적으로 말하면 함수가 20줄을 넘어가지 않도록 작게 만들 수 있어야 한다.

함수의 인자는 0개가 가장 이상적이며, 4개 이상 넘어가지 않도록 주의한다.

### 3.1. 규칙

- 작게 만든다.
- 더 작게 만든다.
- 이름으로 짐작할 수 있는 한 가지 기능만 잘 하도록 만든다.

에러 처리도 하나의 기능이므로 분리하는 것이 좋다.

## 4. 주석

주석이 담고있는 정보와 코드가 담고있는 정보는 높은 확률로 다르기 때문에 잘못된 주석을 다는 것 보다는 주석이 없는 것이 더 좋을 수 있다. 결과적으로 주석은 **주석**일 뿐이고 코드를 대신할 수 없다.

그럼에도 불구하고 좋은 주석은 존재한다.

### 4.1. 좋은 주석

**법적인 주석**

Copyright, 약관 등 코드의 법적인 정보를 주석으로 추가할 수 있다.

**정보를 제공하는 주석**

코드에서 함수나 변수의 이름으로 정보를 표현하는 것이 가장 좋은 방법이지만 주석으로 정보를 표현하는 것이 더 좋은 경우도 존재한다.

```swift
// kk:mm:ss EEE, MMM dd, yyyy 형식
Pattern timeMatcher = Pattern.compile("\\d*:\\d*:\\d* \\w* \\d*, \\d*")
```

**의도를 설명하는 주석**

구현을 넘어서 코드의 의도를 설명하는 주석은 때때로 도움이 되기도 한다.

**의미를 명료하게 하는 주석**

코드가 직접적으로 의미를 표현할 수 있는 것이 가장 이상적이지만 표준 라이브러리나 외부 코드 등 코드를 직접 수정할 수 없는 상황에서 의미를 명료하게 하는 주석은 도움이 된다.

**결과를 경고하는 주석**

코드의 구현이 아니라 결과를 주의하는 주석을 추가하면 다른 프로그래머가 해당 코드를 사용할 때 주의해서 사용할 수 있다.

**ToDo 주석**

해야할 일을 주석으로 남겨두면 해야할 일을 쉽게 정리할 수 있다.

**중요성을 강조하는 주석**

알고리즘 코드에서 중요한 부분을 강조하는 주석을 추가할 수 있다.

```swift
String listItemContent = match.group(3).trim();
// trim은 정말 중요하다. 문자열 시작에 공백이 있으면 다른 문자열로 인식되기 때문이다.
```

형상관리 프로그램이 발전함에 따라 **작성자**를 명시하는 주석, 변경 이력을 기록하는 주석, 코드 자체를 주석으로 처리하는 주석 등은 더이상 필요하지 않게 되었다. 이러한 정보들은 형상관리 프로그램에 위임하고 코드는 깔끔하게 유지하는 것이 좋다.

## 5. 형식 맞추기

코드의 적절한 길이와 양은 통상적으로 해당 시대에 사용하는 모니터 해상도의 영향을 받는다.

코드는 의사소통 수단이기 때문에 형식을 맞추는 것은 **매우** 중요하다. 너무 긴 코드는 가독성이 떨어지기 때문에 하나의 파일은 200줄이 넘지 않도록 하는 것이 좋다. 코드는 위에서 아래로 읽기 때문에 읽으면서 코드의 의도를 파악할 수 있도록 코드의 배치와 길이를 조절해야 한다.

함수가 다른 함수를 호출하는 경우에 두 함수는 가급적 가까운 거리에 위치하도록 배치해야 한다.

세로 밀집도도 중요하지만 코드의 가로 길이도 못지않게 중요하다. 한 줄이 120자가 넘어가면 부주의하게 코드를 작성했다는 뜻이다. 연산자 양 옆은 띄어쓰기를 추가하면 가독성이 높아진다.

가로로 정렬하는 것은 겉보기에는 좋아보이지만 실질적으로 효과가 없다.

```java
// 나쁜 가로 정렬
public class FinNesseExpediter implements ResponseSender {
	private   Socket        socket;
	private   InputStream   input;
	protected long          requestParsingTimeLimit;
}
```

### 5.1. 규칙

- 신문 기사처럼 작성한다.
- 개념은 빈 행으로 분리한다.
- 세로 밀집도와 수직 거리를 고려하면서 코드를 작성한다.
- 가로 정렬을 사용하지 않는다.
- 1줄짜리 블록도 들여쓰기를 한다.

이 모든 규칙은 프로젝트 내에서 동일하게 지켜져야 한다.

## 6. 객체와 자료 구조

`private`로 선언된 모든 변수를 getter와 setter로 공개하는 것은 나쁜 방법이다. 데이터를 추상화하고, 숨겨진 데이터로 가공된 정보를 노출하는 것이 좋다.

절차적인 코드는 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽지만 새로운 자료 구조를 추가하기 힘들다. 반면, 객체지향적인 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽지만 새로운 함수를 추가하기 힘들다.

### 6.1. 규칙

- 객체는 동작을 공개하고 데이터를 숨긴다.
- 자료 구조는 별다른 동작 없이 데이터를 노출한다.
- 두 도구를 적절한 곳에 사용한다.

## 7. 오류 처리

`if`로 오류를 처리하는 것 보다 예외를 던지는 것이 더 깔끔하다. 예외가 발생할 수 있는 로직을 구현할 때는 `try-catch`를 먼저 작성하고 내부적인 알고리즘을 작성하는 것이 더 좋다.

예외를 던질 때 전후 상황을 함께 추가하면 예외를 처리하는 측에서의 작업이 더 쉬워진다.

### 7.1. 규칙

- `null`을 반환하지 않는다.
- `null`을 전달하지 않는다.

## 8. 경계

외부 라이브러리를 사용할 때 경계를 최소화해야 한다. 내부 코드와 맞붙어있는 부분이 많을 수록 코드를 수정하기 힘들어진다. 프로그램에서 사용하는 방식대로 모듈을 호출하고, 모듈에서 외부 라이브러와 소통한다.

## 9. 단위 테스트

TDD(Test Driven Development) 개념을 적극 활용해서 개발한다.

### 9.1. 규칙

- 실패하는 단위 테스트를 작성하기 전까지 실제 코드를 작성하지 않는다.
- 컴파일은 성공하지만 실행은 실패하는 단위 테스트를 작성한다.
- 현재 실패하는 테스트를 성공할 정도로만 코드를 작성한다.
- 테스트 당 하나의 `assert`만 사용해서 하나의 개념만 테스트하도록 한다.
- 빠르고(First), 독립적이고(Individual), 반복 가능하며(Repeatable) 자가 검증하는(Self-Validating) 적시(Timely) 테스트를 작성한다. (FIRST 규칙)

## 10. 클래스

클래스는 신문기사처럼 읽을 수 있어야 한다. 위에서부터 정적 공개 상수 → 정적 비공개 변수 → 비공개 인스턴스 변수 → 공개 함수 → 비공개 함수 순서로 작성한다.

클래스의 크기는 작을 수록 좋다. 

하나의 클래스는 하나의 책임만 맡도록 작성한다.

### 10.1. 규칙

- 단일 책임 원칙을 지키도록 클래스를 분리한다.
- 클래스의 응집도를 유지할 수 있는 최대한 작은 단위로 분리한다.
- 변경하기 쉽도록 작성한다.

## 11. 시스템

시스템을 초기화하는 시작단계와 사용단계는 서로 다른 관심사를 가진다. 두 관심사를 분리하면 사용 단계에서는 생성 과정을 몰라도 동작할 수 있다.

처음부터 완벽한 설계를 할 수는 없다. 반복적이고 점진적으로 시스템을 개선하고 확장할 수 있도록 만들어야 한다.

### 11.1. 규칙

- 관심사를 분리한다.
- 의사 결정을 최적화한다.
- 명백한 가치가 있을 때 표준을 현명하게 사용한다.
- 실제로 돌아가는 가장 단순한 수단을 사용한다.

## 12. 창발성

복잡한 구조 위에는 창의적인 코드가 나올 수 없다. 단순한 설계는 **창발성**을 촉진한다.

### 12.1. 켄트 벡이 제시하는 단순하 설계를 위한 4가지 규칙

- 모든 테스트를 실행한다.
- 중복을 없앤다.
- 프로그래머의 의도를 표현한다.
- 클래스와 메서드 수를 최소로 줄인다.

결합도가 높으면 테스트를 작성하기 힘들어진다. 의존성 주입, 인터페이스 추상화 등을 통해 테스트하기 쉬운 설계를 만들면 결과적으로 시스템의 품질이 높아진다.

단순히 몇 줄이라도 중복을 없애려고 노력한다면 시스템은 더 좋은 설계를 가진다. **Template Method**패턴은 이러한 중복을 제거하는데 효율적인 접근을 제공한다.

좋은 이름과 짧은 함수, 짧은 클래스를 만들어서 코드만 읽어도 의도를 파악할 수 있도록 한다.

## 13. 동시성

여러 스레드를 사용하는 **동시성**과 깔끔한 코드는 양립하기 힘든 속성이다. 동시성은 일반적으로 **어렵다.** 하지만 동시성을 포기할 수는 없기 때문에 최대한 방어적인 설계가 필요하다.

### 13.1. 규칙

- 동시성 코드는 다른 코드와 분리한다.
- 자료를 캡슐화 하고 공유 자료를 최대한 줄인다.
- 독립적인 스레드를 구현한다.
- 순차적인 코드 부터 정확히 구현한 후에 동시성 코드를 추가한다.

동시성 프로그램에서 발생하는 오류는 테스트를 통과했다고 해서 그 안전성을 보장하지 않는다. 더 열악한 환경에서, 더 많은 테스트를 수행해서 최대한 오류를 많이 찾아내는 수 밖에 없다.

## 14. 점진적인 개선

프로그래밍은 과학 보다는 **공예**에 가깝다. 깨끗한 코드를 짜려면 먼저 코드를 짠 뒤에 정리해야 한다.

개선이라는 이름 하에 코드의 구조를 크게 뒤집는 행위는 프로그램을 망치는 가장 좋은 방법이다. 코드가 지저분해진다고 생각이 들면 개발을 멈추고 당장 개선해야 한다.
