# Clean Code

이 문서는 *Robert. C. Martin*의 책 **Clean Code**를 읽고 정리하는 문서로 책에서 제시하는 좋은 코드를 작성하기 위해 책에서 제시하는 아이디어를 요약합니다. 요약을 위해서 짧은 문장과 **규칙**이라는 목록으로 아이디어를 나열하지만 실제 책에서는 절대 그 어떤 아이디어에 대해서, 이 방법만이 정답이고 다른 방법으로 작성하는 것은 틀렸다고 하지 않습니다.

## 깨끗한 코드

깨끗한 코드는 잘 쓴 하나의 문장처럼 읽을 수 있어야 한다. 즉, 코드를 읽으면서 짐작했던 기능을 그대로 수행해야 한다.

규칙:

- 중복을 피하라
- 한 기능만 수행하라
- 제대로 표현하라
- 작게 추상화하라

위 아이디어를 지키면서 **주의 깊게** 코드를 작성할 수 있어야 한다.

불가피하게 모듈에 기능을 추가하거나 수정을 해야 한다면 수정하기 전보다 더 깨끗하게 만들어 놓고 다음 작업으로 넘어가도록 한다.

## 의미있는 이름

의도가 분명하게 이름을 짓는 것은 **정말** 중요하다. 존재 이유, 수행 기능, 사용 방법을 모두 이름을 통해 짐작할 수 있어야 한다. 이름이 다르다면 의미도 달라져야 하며 비슷한 이름은 지양해야 한다. 

규칙:

- 실제 단어를 사용하라. 임의로 만들어낸 새로운 단어나 `i`같은 알파벳은 지양하라
- 클래스 이름으로는 명사를 사용하라
- 메서드 이름으로는 동사를 사용하라

맥락이 있는 이름을 사용해서 더 빠르게 의미를 짐작할 수 있도록 한다. `state` 보다는 `addrState`가, 더 나아가서는 `addressState`가 더 좋은 이름이다.

## 함수

함수를 작게 만들수록 상위 함수의 흐름을 이해하기 쉬워진다. 함수를 작게 만들 수록 코드를 더욱 문장처럼 작성할 수 있다.

극단적으로 말하면 함수가 20줄을 넘어가지 않도록 작게 만들 수 있어야 하며, 함수의 인자는 0개가 가장 이상적이며, 4개 이상 넘어가지 않도록 만든다.

규칙:

- 작게 만들어라
- 더 작게 만들어라
- 이름으로 짐작할 수 있는 한 가지 기능만 잘 하도록 만들어라

에러 처리도 하나의 기능이므로 분리하는 것이 좋다.

## 주석

주석이 담고있는 정보와 코드가 담고있는 정보는 높은 확률로 다르기 때문에 잘못된 주석을 다는 것 보다는 주석이 없는 것이 더 좋을 수 있다. 결과적으로 주석은 **주석**일 뿐이고 코드를 대신할 수 없다.

그럼에도 불구하고 좋은 주석은 존재한다.

- 법적인 주석: Copyright, 약관 등 코드의 법적인 정보를 주석으로 추가할 수 있다.
- 정보를 제공하는 주석: 코드에서 함수나 변수의 이름으로 정보를 표현하는 것이 가장 좋은 방법이지만 주석으로 정보를 표현하는 것이 더 좋은 경우도 존재한다.

    ```swift
    // kk:mm:ss EEE, MMM dd, yyyy 형식
    Pattern timeMatcher = Pattern.compile("\\d*:\\d*:\\d* \\w* \\d*, \\d*")
    ```

- 의도를 설명하는 주석: 구현을 넘어서 코드의 의도를 설명하는 주석은 때때로 도움이 되기도 한다.
- 의미를 명료하게 하는 주석: 코드가 직접적으로 의미를 표현할 수 있는 것이 가장 이상적이지만 표준 라이브러리나 외부 코드 등 코드를 직접 수정할 수 없는 상황에서 의미를 명료하게 하는 주석은 도움이 된다.
- 결과를 경고하는 주석: 코드의 구현이 아니라 결과를 주의하는 주석을 추가하면 다른 프로그래머가 해당 코드를 사용할 때 주의해서 사용할 수 있다.
- TODO 주석: 해야할 일을 주석으로 남겨두면 해야할 일을 쉽게 정리할 수 있다.
- 중요성을 강조하는 주석: 알고리즘 코드에서 중요한 부분을 강조하는 주석을 추가할 수 있다.

    ```swift
    String listItemContent = match.group(3).trim();
    // trim은 정말 중요하다. 문자열 시작에 공백이 있으면 다른 문자열로 인식되기 때문이다.
    ```

형상관리 프로그램이 발전함에 따라 **작성자**를 명시하는 주석, 변경 이력을 기록하는 주석, 코드 자체를 주석으로 처리하는 주석 등은 더이상 필요하지 않게 되었다. 위 사항들은 형상관리 프로그램에 위임하고 코드는 깔끔하게 유지하는 것이 좋다.

## 형식 맞추기

코드는 의사소통 수단이기 때문에 형식을 맞추는 것은 **중요**하다. 너무 긴 코드는 가독성이 떨어지기 때문에 하나의 파일은 200줄이 넘지 않도록 하는 것이 좋다. 코드는 위에서 아래로 읽기 때문에 읽으면서 코드의 의도를 파악할 수 있도록 코드의 배치와 길이를 조절해야 한다. 

함수가 다른 함수를 호출하는 경우에 두 함수는 가급적 가까운 거리에 위치하도록 배치해야 한다.

세로 밀집도도 중요하지만 코드의 가로 길이도 못지않게 중요하다. 한 줄이 120자가 넘어가면 부주의하게 코드를 작성했다는 뜻이다. 연산자 양 옆은 띄어쓰기를 추가하면 가독성이 높아진다.

가로로 정렬하는 것은 겉보기에는 좋아보이지만 실질적으로 효과가 없다.

```java
// 나쁜 가로 정렬
public class FinNesseExpediter implements ResponseSender {
	private   Socket        socket;
	private   InputStream   input;
	protected long          requestParsingTimeLimit;
}
```

규칙:

- 신문 기사처럼 작성하라
- 개념은 빈 행으로 분리하라
- 세로 밀집도와 수직 거리를 고려하면서 코드를 작성하라
- 가로 정렬을 사용하지 마라
- 1줄짜리 블록도 들여쓰기를 하라

이 모든 규칙은 프로젝트 내에서 동일하게 지켜져야 한다.

## 객체와 자료 구조

`private`로 선언된 변수를 getter와 setter로 공개하는 것은 나쁜 방법이다. 데이터를 추상화하고, 숨겨진 데이터로 가공된 정보를 노출하는 것이 좋다.

절차적인 코드는 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽지만 새로운 자료 구조를 추가하기 힘들다. 반면, 객체지향적인 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽지만 새로운 함수를 추가하기 힘들다.

규칙:

- 객체는 동작을 공개하고 자료를 숨긴다.
- 자료 구조는 별다른 동작 없이 자료를 노출한다.
- 두 도구를 적절한 곳에 사용하라

## 오류 처리

`if`로 오류를 처리하는 것 보다 예외를 던지는 것이 더 깔끔하다. 예외가 발생할 수 있는 로직을 구현할 때는 `try-catch`를 먼저 작성하고 내부적인 알고리즘을 작성하는 것이 더 좋다.

예외를 던질 때 전후 상황을 함께 추가하면 예외를 처리하는 측에서의 작업이 더 쉬워진다.

규칙: 

- `null`을 반환하지 마라
- `null`을 전달하지 마라

## 경계

외부 라이브러리를 사용할 때 경계를 최소화해야 한다. 내부 코드와 맞붙어있는 부분이 많을 수록 코드를 수정하기 힘들어진다. 프로그램에서 사용하는 방식대로 모듈을 호출하고, 모듈에서 외부 라이브러와 소통한다.

## 단위 테스트

TDD(Test Driven Development) 개념을 적극 활용해서 개발한다.

규칙:

- 실패하는 단위 테스트를 작성하기 전까지 실제 코드를 작성하지 않는다.
- 컴파일은 성공하지만 실행은 실패하는 단위 테스트를 작성한다.
- 현재 실패하는 테스트를 성공할 정도로만 코드를 작성한다.
- 테스트 당 하나의 `assert`만 사용해서 하나의 개념만 테스트하도록 한다.
- 빠르고(First), 독립적이고(Individual), 반복 가능하며(Repeatable) 자가 검증하는(Self-Validating) 적시(Timely) 테스트를 작성한다. (FIRST 규칙)

## 클래스

클래스는 신문기사처럼 읽을 수 있어야 한다. 정적 공개 상수가 가장 먼저 나오고 정적 비공개 변수, 비공개 인스턴스 변수, 공개 함수, 비공개 함수 순서로 작성한다.

클래스의 크기는 작을 수록 좋다. 하나의 클래스는 하나의 책임만 맡도록 작성한다.

규칙:

- 단일 책임 원칙을 지키도록 클래스를 분리한다.
- 클래스의 응집도를 유지할 수 있는 최대한 작은 단위로 분리하라.
- 변경하기 쉽도록 작성하라.